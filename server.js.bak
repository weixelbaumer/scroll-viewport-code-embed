/**
 * GitHub Code Renderer
 * A simple service to render GitHub code snippets with syntax highlighting
 * for embedding in Confluence with Scroll Viewport
 */

const express = require('express');
const axios = require('axios');
const cors = require('cors');
const highlight = require('highlight.js');
const cache = require('memory-cache');
const dotenv = require('dotenv');
const path = require('path');
const fs = require('fs');

// Load environment variables
dotenv.config();

// Constants
const PORT = process.env.PORT || 3000;
const CACHE_DURATION = parseInt(process.env.CACHE_DURATION) || 1800000; // Default: 30 minutes
const DEBUG = process.env.DEBUG === 'true';
const DEFAULT_THEME = process.env.DEFAULT_THEME || 'github';
const ALLOWED_ORIGINS = process.env.ALLOWED_ORIGINS || '*';
const NGROK_URL = process.env.NGROK_URL || '';

// Complete ngrok bypass script - more comprehensive version
const NGROK_BYPASS_SCRIPT = `
// Try to break out of iframe if we're in one - this helps bypass ngrok warnings
(function() {
  // This attempts to break out of ANY iframe - useful for bypassing ngrok warning
  if (window !== window.top) {
    try {
      // Try to break out of the iframe
      window.top.location.href = window.location.href;
    } catch(e) {
      console.error("Failed to break out of iframe:", e);
    }
  }
})();

// Override ngrok warning functions
window.ngrokCheckParentFrameIsNotNgrok = function() { return true; };
window.ngrokWarnUserIfParentFrameIsNgrok = function() { return false; };

// Also override any other potential ngrok warning mechanisms
if (window.self) {
  window.self.ngrokCheckParentFrameIsNotNgrok = function() { return true; };
  window.self.ngrokWarnUserIfParentFrameIsNgrok = function() { return false; };
}

// Prevent any future redefinitions
Object.defineProperty(window, 'ngrokCheckParentFrameIsNotNgrok', {
  value: function() { return true; },
  writable: false,
  configurable: false
});

Object.defineProperty(window, 'ngrokWarnUserIfParentFrameIsNgrok', {
  value: function() { return false; },
  writable: false,
  configurable: false
});

// SPECIFIC HANDLER FOR THE CURRENT NGROK WARNING PAGE
// Based on the screenshot, the warning page has a button with text "Visit Site"
function bypassNgrokWarningPage() {
  console.log("‚ö†Ô∏è Attempting to bypass ngrok warning");
  
  // First - check if we're on the ngrok warning page
  const isNgrokWarningPage = 
    document.body && 
    document.body.textContent && 
    document.body.textContent.includes("ngrok.com") &&
    document.body.textContent.includes("Visit Site");
  
  if (!isNgrokWarningPage) {
    console.log("Not on ngrok warning page");
    return false;
  }
  
  console.log("‚úÖ Detected ngrok warning page, attempting bypass");
  
  // Try to find the specific Visit Site button from the screenshot
  // The closest element seen in the screenshot is a blue button at the bottom
  try {
    // Find all links that look like buttons
    const visitSiteLinks = Array.from(document.querySelectorAll('a.button, a.btn, button, a[role="button"]'));
    for (const link of visitSiteLinks) {
      if (link.textContent && link.textContent.trim() === 'Visit Site') {
        console.log('üéØ Found Visit Site button, clicking it!');
        link.click();
        return true;
      }
    }
    
    // Look more broadly for links
    const allLinks = Array.from(document.getElementsByTagName('a'));
    for (const link of allLinks) {
      if (link.textContent && link.textContent.trim() === 'Visit Site') {
        console.log('üîç Found Visit Site link, clicking it!');
        link.click();
        return true;
      }
    }
    
    // Look for any element with that text and click it
    const allElements = Array.from(document.querySelectorAll('*'));
    for (const element of allElements) {
      if (element.textContent && element.textContent.trim() === 'Visit Site') {
        console.log('‚ö° Found element with Visit Site text, clicking!');
        element.click();
        return true;
      }
    }
    
    // Direct DOM modification - find the element with class="button"
    // From the screenshot we can see it's a blue button with this styling
    const blueButtons = Array.from(document.querySelectorAll('.button, .btn'));
    for (const button of blueButtons) {
      console.log('üí• Found a button element, clicking it: ', button.textContent);
      button.click();
      return true;
    }
    
    console.log('‚ùå Could not find Visit Site button');
    return false;
  } catch (error) {
    console.error('Error bypassing ngrok warning:', error);
    return false;
  }
}

// Try to bypass on page load and repeatedly
function attemptBypass() {
  bypassNgrokWarningPage();
  
  // Try again a few times with increasing delays
  setTimeout(bypassNgrokWarningPage, 300);
  setTimeout(bypassNgrokWarningPage, 600);
  setTimeout(bypassNgrokWarningPage, 1000);
  setTimeout(bypassNgrokWarningPage, 2000);
}

// Run as soon as possible
attemptBypass();

// Also run when the DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', attemptBypass);
} else {
  attemptBypass();
}

// And when the page has loaded
window.addEventListener('load', attemptBypass);

// Fallback to the older methods if needed
// Auto-click the "Visit Site" button - without jQuery dependencies
function clickVisitSiteButton() {
  // Try multiple selector strategies for the "Visit Site" button
  const selectors = [
    'a.button', 
    'button.button', 
    'a.btn', 
    'button.btn', 
    '[role="button"]',
    // More specific selectors based on the screenshot
    '#visit-site',
    '.visit-site'
  ];
  
  // Try each selector
  for (const selector of selectors) {
    try {
      const elements = document.querySelectorAll(selector);
      for (const element of elements) {
        if (element.textContent && element.textContent.trim() === 'Visit Site') {
          console.log('Found Visit Site button, clicking it');
          element.click();
          return true;
        }
      }
    } catch (e) {
      console.error('Error with selector:', selector, e);
    }
  }
  
  // Find any links with the text 'Visit Site'
  try {
    const links = document.getElementsByTagName('a');
    for (const link of links) {
      if (link.textContent && link.textContent.trim() === 'Visit Site') {
        console.log('Found Visit Site link, clicking it');
        link.click();
        return true;
      }
    }
  } catch (e) {
    console.error('Error finding Visit Site link:', e);
  }
  
  // Find any buttons with the text 'Visit Site'
  try {
    const buttons = document.getElementsByTagName('button');
    for (const button of buttons) {
      if (button.textContent && button.textContent.trim() === 'Visit Site') {
        console.log('Found Visit Site button, clicking it');
        button.click();
        return true;
      }
    }
  } catch (e) {
    console.error('Error finding Visit Site button:', e);
  }
  
  // Last resort: look for any element with "Visit Site" text
  try {
    const allElements = document.querySelectorAll('*');
    for (const element of allElements) {
      if (element.textContent && element.textContent.trim() === 'Visit Site') {
        console.log('Found Visit Site text, clicking element');
        element.click();
        // Also try parent element
        if (element.parentElement) {
          element.parentElement.click();
        }
        return true;
      }
    }
  } catch (e) {
    console.error('Error with all elements search:', e);
  }
  
  return false;
}

// Try repeatedly to find and click the button
let visitSiteAttempts = 0;
function tryClickVisitSite() {
  if (visitSiteAttempts++ < 20) { // Increase attempts
    if (!clickVisitSiteButton()) {
      setTimeout(tryClickVisitSite, 300); // More frequent checks
    }
  }
}

// Try immediately
tryClickVisitSite();

// Also try when the DOM is ready and when the page has fully loaded
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', tryClickVisitSite);
} else {
  tryClickVisitSite();
}
window.addEventListener('load', tryClickVisitSite);

// Direct modification of the page if it's the ngrok warning
setTimeout(function() {
  // Check if we're on the ngrok warning page by looking for specific text
  if (document.body && document.body.textContent.includes('ngrok.com') && 
      document.body.textContent.includes('Visit Site')) {
    
    // Find the Visit Site link/button programmatically
    const links = document.getElementsByTagName('a');
    for (let i = 0; i < links.length; i++) {
      if (links[i].textContent && links[i].textContent.trim() === 'Visit Site') {
        links[i].click();
        break;
      }
    }
  }
}, 1000);
`;

// Initialize express
const app = express();

// Enable CORS
app.use(cors({
  origin: function(origin, callback) {
    // If no origins are specified, allow all
    if (!ALLOWED_ORIGINS || ALLOWED_ORIGINS === '*') {
      return callback(null, true);
    }
    
    // Check if the origin is in the allowed list
    if (ALLOWED_ORIGINS.split(',').indexOf(origin) !== -1 || !origin) {
      return callback(null, true);
    }
    
    return callback(new Error('Not allowed by CORS'));
  },
  optionsSuccessStatus: 200
}));

// Add ngrok-skip-browser-warning header for all responses
app.use((req, res, next) => {
  // Set proper headers to bypass ngrok warning
  res.setHeader('ngrok-skip-browser-warning', 'true');
  res.setHeader('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36');
  
  // Set other headers that might help bypass the warning
  res.setHeader('X-Forwarded-For', '127.0.0.1');
  res.setHeader('X-Requested-With', 'XMLHttpRequest');
  
  next();
});

// Middleware to ensure correct content type for JS files
app.use((req, res, next) => {
  const path = req.path;
  if (path.endsWith('.js')) {
    // Store the original send method
    const originalSend = res.send;
    
    // Override the send method
    res.send = function(body) {
      // Set proper JavaScript MIME type
      if (!res.get('Content-Type')) {
        res.set('Content-Type', 'application/javascript; charset=utf-8');
      }
      res.set('X-Content-Type-Options', 'nosniff');
      
      // Call the original send method
      return originalSend.call(this, body);
    };
  }
  next();
});

// Serve static files from the public directory
app.use(express.static(path.join(__dirname, 'public')));

// GitHub API configuration
const githubConfig = {
  headers: {
    'Accept': 'application/vnd.github.v3.raw',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36',
    'ngrok-skip-browser-warning': 'true'
  }
};

// Only add token if it exists
if (process.env.GITHUB_TOKEN) {
  githubConfig.headers['Authorization'] = `token ${process.env.GITHUB_TOKEN}`;
  console.log('GitHub token configured');
} else {
  console.log('No GitHub token provided. Rate limits for public repositories will apply.');
}

// Main route for documentation 
app.get('/', (req, res) => {
  res.send(`
    <html>
      <head>
        <title>GitHub Code Renderer</title>
        <style>
          body { font-family: Arial, sans-serif; line-height: 1.6; margin: 0; padding: 20px; max-width: 800px; margin: 0 auto; }
          h1 { color: #333; }
          pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }
          a { color: #0066cc; text-decoration: none; }
          a:hover { text-decoration: underline; }
          .menu { display: flex; gap: 20px; margin-bottom: 20px; }
          .menu a { padding: 8px 16px; background-color: #f0f0f0; border-radius: 4px; }
          .menu a:hover { background-color: #e0e0e0; text-decoration: none; }
          .card { background-color: #fff; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); padding: 20px; margin-bottom: 20px; }
          .alert { padding: 15px; margin-bottom: 20px; border-radius: 4px; }
          .alert-danger { background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; }
          .alert-warning { background-color: #fff3cd; border: 1px solid #ffeeba; color: #856404; }
          .alert-info { background-color: #d1ecf1; border: 1px solid #bee5eb; color: #0c5460; }
          .btn { display: inline-block; padding: 8px 16px; margin: 5px 0; border-radius: 4px; text-decoration: none; }
          .btn-primary { background-color: #0066cc; color: white; }
          .btn-danger { background-color: #dc3545; color: white; }
          .btn-warning { background-color: #ffc107; color: #333; }
        </style>
      </head>
      <body>
        <h1>GitHub Code Renderer</h1>
        
        <div class="menu">
          <a href="/">Home</a>
          <a href="/direct-embed.html">Direct Embed Tool</a>
          <a href="/scroll-viewport-test.html">Scroll Viewport Demo</a>
          <a href="/scroll-viewport.html">Scroll Viewport Guide</a>
          <a href="/theme/docs.html">Theme Integration</a>
          <a href="/atlassian-connect-bypass.json">Atlassian Connect Descriptor</a>
        </div>
        
        <div class="alert alert-danger">
          <h3 style="margin-top:0">IMPORTANT: Scroll Viewport Users</h3>
          <p>Scroll Viewport <strong>filters out HTML tags</strong> from embedded content!</p>
          <p>Use our special JavaScript solution to bypass this limitation:</p>
          <a href="/scroll-viewport.html" class="btn btn-danger">Scroll Viewport Solution Guide</a>
          <a href="/theme/docs.html" class="btn btn-danger">Theme Integration Guide</a>
          <a href="/scroll-viewport-test.html" class="btn btn-danger">See Working Demo</a>
        </div>
        
        <div class="card">
          <h2>How to Use</h2>
          <p>This service renders GitHub code snippets with syntax highlighting. Choose your preferred method:</p>
          
          <h3>Option 1: For Scroll Viewport Users (Theme Integration)</h3>
          <p>Use our <strong>theme-based solution</strong> that works with Scroll Viewport's static pages:</p>
          <p><a href="/theme/docs.html" class="btn btn-primary">View Theme Integration Guide</a></p>
          
          <h3>Option 2: For Scroll Viewport Users (JavaScript Method)</h3>
          <p>Alternative JavaScript-based solution that injects code <em>after</em> Scroll Viewport filters content:</p>
          <pre>&lt;script src="${req.protocol}://${req.get('host')}/scroll-viewport.js?url=YOUR_GITHUB_URL"&gt;&lt;/script&gt;</pre>
          <p><a href="/scroll-viewport.html" class="btn btn-primary">View JavaScript Guide</a></p>
          
          <h3>Option 3: Direct Embed HTML</h3>
          <p>For regular Confluence pages (not using Scroll Viewport), use the <a href="/direct-embed.html">Direct Embed Tool</a> to generate HTML code for a Confluence HTML macro.</p>
          
          <h3>Option 4: Atlassian Connect App</h3>
          <p>Install this app in your Confluence instance using the <a href="/skip-ngrok.html">installation page</a>. This adds a "GitHub Code" macro to your Confluence editor.</p>
          
          <h3>Option 5: Direct HTML API</h3>
          <p>Use the HTML API endpoint directly:</p>
          <pre>GET /html?url={githubUrl}&theme={theme}&lines={lineRange}</pre>
          <p>Example: <a href="/html?url=https://github.com/itext/itext7/blob/develop/kernel/src/main/java/com/itextpdf/kernel/pdf/PdfDocument.java&lines=100-120&theme=github">/html?url=https://github.com/itext/itext7/blob/develop/kernel/src/main/java/com/itextpdf/kernel/pdf/PdfDocument.java&lines=100-120&theme=github</a></p>
        </div>
      </body>
    </html>
  `);
});

// HTML rendering endpoint with better URL parsing
app.get('/html', async (req, res) => {
  try {
    const { url, lines, theme } = req.query;
    
    if (!url) {
      return res.status(400).send('GitHub URL is required');
    }
    
    console.log(`Processing URL for HTML output: ${url}`);
    
    // Validate URL format
    if (!url.includes('github.com') && !url.includes('raw.githubusercontent.com')) {
      console.error(`Invalid GitHub URL format: ${url}`);
      return res.status(400).send(`Invalid GitHub URL format: ${url}. URL must contain github.com or raw.githubusercontent.com`);
    }
    
    let code = '';
    
    // Direct fetch of the raw content
    try {
      // Use the URL as-is if it's already a raw URL, otherwise convert it
      const fetchUrl = url.includes('raw.githubusercontent.com') 
        ? url 
        : url.replace(/https?:\/\/github\.com/i, 'https://raw.githubusercontent.com')
              .replace('/blob/', '/');
      
      // Validate transformed URL
      if (!fetchUrl.startsWith('https://') && !fetchUrl.startsWith('http://')) {
        console.error(`Invalid transformed URL: ${fetchUrl} (original: ${url})`);
        return res.status(400).send(`Error: Transformed URL is invalid. Original URL may be incomplete.`);
      }
      
      // Check if URL structure looks correct
      if (!fetchUrl.match(/https?:\/\/raw\.githubusercontent\.com\/[^\/]+\/[^\/]+\/[^\/]+\//i)) {
        console.error(`Malformed GitHub raw URL: ${fetchUrl} (original: ${url})`);
        return res.status(400).send(`Error: GitHub URL appears to be malformed or incomplete.`);
      }
      
      console.log(`Fetching from: ${fetchUrl}`);
      
      const response = await axios.get(fetchUrl, {
        headers: {
          'User-Agent': 'GitHub-Code-Renderer',
          'Accept': 'text/plain'
        }
      });
      
      code = response.data;
      console.log(`Fetched ${code.length} bytes of code`);
      
      // Extract specific lines if requested
      if (lines) {
        code = extractLines(code, lines);
      }
    } catch (error) {
      console.error('Error fetching code:', error.message);
      return res.status(500).send(`Error fetching code: ${error.message}`);
    }
    
    // Extract filename from URL
    const filename = url.split('/').pop() || 'code';
    
    // Determine language from file extension
    const extension = filename.split('.').pop().toLowerCase();
    const language = detectLanguage(extension);
    
    // Apply syntax highlighting
    let highlightedCode = '';
    try {
      highlightedCode = highlightCode(code, language);
    } catch (error) {
      console.error('Error highlighting code:', error.message);
      // Fallback to plain text with HTML escaping
      highlightedCode = code.replace(/&/g, '&amp;')
                             .replace(/</g, '&lt;')
                             .replace(/>/g, '&gt;')
                             .replace(/"/g, '&quot;')
                             .replace(/'/g, '&#039;');
    }
    
    // Get theme-specific styles
    const themeStyles = getThemeStyles(theme || DEFAULT_THEME);
    
    // Create the HTML snippet
    const html = `
<div class="github-code">
  <style>
    .github-code { font-family: monospace; margin: 10px 0; }
    .github-code-header { background: #f1f1f1; padding: 10px; border: 1px solid #ddd; border-bottom: none; }
    .github-code-content { padding: 10px; border: 1px solid #ddd; overflow-x: auto; }
    .github-code pre { margin: 0; white-space: pre; }
    ${themeStyles}
  </style>
  <div class="github-code-header">
    <strong>${filename}</strong> <span style="float:right">${language}</span>
  </div>
  <div class="github-code-content">
    <pre><code>${highlightedCode}</code></pre>
  </div>
  <div class="github-code-footer" style="background: #f1f1f1; padding: 10px; border: 1px solid #ddd; border-top: none;">
    <a href="${url}" target="_blank" style="color: #0366d6; text-decoration: none;">View on GitHub</a>
  </div>
</div>`;
    
    // Set content type to plain text so it can be copied
    res.set('Content-Type', 'text/plain');
    res.send(html);
    
  } catch (error) {
    console.error('General error:', error.message);
    res.status(500).send(`Error: ${error.message}`);
  }
});

// Universal GitHub code renderer endpoint - PURE HTML ONLY
app.get('/render', async (req, res) => {
  try {
    const { url, lines, theme } = req.query;
    
    if (!url) {
      return res.status(400).send('GitHub URL is required');
    }
    
    console.log(`Processing URL: ${url}`);
    
    let code = '';
    
    // Direct fetch of the raw content
    try {
      // Use the URL as-is if it's already a raw URL, otherwise convert it
      const fetchUrl = url.includes('raw.githubusercontent.com') 
        ? url 
        : url.replace(/https?:\/\/github\.com/i, 'https://raw.githubusercontent.com')
              .replace('/blob/', '/');
      
      console.log(`Fetching from: ${fetchUrl}`);
      
      const response = await axios.get(fetchUrl, {
        headers: {
          'User-Agent': 'GitHub-Code-Renderer',
          'Accept': 'text/plain'
        }
      });
      
      code = response.data;
      console.log(`Fetched ${code.length} bytes of code`);
      
      // Extract specific lines if requested
      if (lines) {
        code = extractLines(code, lines);
      }
    } catch (error) {
      console.error('Error fetching code:', error.message);
      return res.status(500).send(`Error fetching code: ${error.message}`);
    }
    
    // Extract filename from URL
    const filename = url.split('/').pop() || 'code';
    
    // Determine language from file extension
    const extension = filename.split('.').pop().toLowerCase();
    const language = detectLanguage(extension);
    
    // Apply syntax highlighting
    let highlightedCode = '';
    try {
      highlightedCode = highlightCode(code, language);
    } catch (error) {
      console.error('Error highlighting code:', error.message);
      // Fallback to plain text with HTML escaping
      highlightedCode = code.replace(/&/g, '&amp;')
                             .replace(/</g, '&lt;')
                             .replace(/>/g, '&gt;')
                             .replace(/"/g, '&quot;')
                             .replace(/'/g, '&#039;');
    }
    
    // Get theme-specific styles
    const themeStyles = getThemeStyles(theme || DEFAULT_THEME);
    
    // Return ONLY the HTML content, no wrappers, or scripts
    const html = `
<div class="github-code">
  <style>
    .github-code { font-family: monospace; margin: 10px 0; }
    .github-code-header { background: #f1f1f1; padding: 10px; border: 1px solid #ddd; border-bottom: none; }
    .github-code-content { padding: 10px; border: 1px solid #ddd; overflow-x: auto; }
    .github-code pre { margin: 0; white-space: pre; }
    ${themeStyles}
  </style>
  <div class="github-code-header">
    <strong>${filename}</strong> <span style="float:right">${language}</span>
  </div>
  <div class="github-code-content">
    <pre><code>${highlightedCode}</code></pre>
  </div>
  <div class="github-code-footer" style="background: #f1f1f1; padding: 10px; border: 1px solid #ddd; border-top: none;">
    <a href="${url}" target="_blank" style="color: #0366d6; text-decoration: none;">View on GitHub</a>
  </div>
</div>`;
    
    // Set content type to plain text to prevent any interpretation
    res.set('Content-Type', 'text/html');
    res.send(html);
    
  } catch (error) {
    console.error('General error:', error.message);
    res.status(500).send(`Error: ${error.message}`);
  }
});

// Scroll Viewport script endpoint
app.get('/scroll-viewport-script', (req, res) => {
  const defaultTheme = req.query.defaultTheme || 'github';
  
  res.set('Content-Type', 'application/javascript');
  
  // This JavaScript will be executed in the Scroll Viewport context
  const script = `
/**
 * GitHub Code Renderer for Scroll Viewport
 * This version has NO dependencies on require() or any Atlassian/Confluence APIs
 */
(function() {
  // Initialize GitHub Code Renderer
  console.log("GitHub Code Renderer initializing...");
  
  // Define the base URL for API requests - guaranteed HTTPS
  var apiBaseUrl = "${req.protocol}://${req.get('host')}";
  if (apiBaseUrl.startsWith("http://")) {
    apiBaseUrl = apiBaseUrl.replace("http://", "https://");
  }
  console.log("GitHub Code Renderer initialized with API URL:", apiBaseUrl);
  
  // Wait until DOM is fully loaded before processing
  function domReady(callback) {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', callback);
    } else {
      callback();
    }
  }
  
  // Find all text nodes that match GitHub code markers
  function findAndProcessGitHubMarkers() {
    console.log("Scanning document for GitHub code markers...");
    
    // Create a tree walker to find all text nodes
    var textNodes = [];
    var walker = document.createTreeWalker(
      document.body,
      NodeFilter.SHOW_TEXT,
      null,
      false
    );
    
    // Collect all text nodes
    var node;
    while (node = walker.nextNode()) {
      textNodes.push(node);
    }
    
    // Define regex for GitHub markers: ##GITHUB:URL:LINES:THEME##
    // Fix the regex pattern to correctly capture the entire GitHub URL
    var markerPattern = "##GITHUB:(https?:\\/\\/(?:github\\.com|raw\\.githubusercontent\\.com)[^#]+)(?::([^:]+))?(?::([^#]+))?##";
    var markerRegex = new RegExp(markerPattern, "g");
    
    // Process each text node
    var markersFound = 0;
    textNodes.forEach(textNode => {
      const text = textNode.nodeValue;
      if (text.includes('##GITHUB:')) {
        const parts = text.split(markerRegex);
        if (parts.length > 1) {
          const parent = textNode.parentNode;
          
          // Remove the original text node
          parent.removeChild(textNode);
          
          // Rebuild the content
          for (let i = 0; i < parts.length; i++) {
            if (i % 4 === 0) {
              // This is regular text before/after/between markers
              if (parts[i]) {
                parent.appendChild(document.createTextNode(parts[i]));
              }
            } else if (i % 4 === 1) {
              // This is the URL
              const url = parts[i];
              const lines = parts[i+1] || ''; // Optional lines parameter
              const theme = parts[i+2] || defaultTheme; // Optional theme parameter
              
              // Create a placeholder
              const placeholder = document.createElement('div');
              placeholder.classList.add('github-code-placeholder');
              placeholder.innerHTML = '<p>Loading code from GitHub...</p>';
              parent.appendChild(placeholder);
              
              // Fetch and render the code
              fetchAndRenderCode(url, placeholder, theme, lines);
              
              // Skip the other captured groups
              i += 2;
            }
          }
        }
      }
    });
  }
  
  // Function to process data-github-embed elements
  function processGitHubEmbeds() {
    // Find all elements with the data-github-embed attribute
    const embeds = document.querySelectorAll('[data-github-embed="true"]');
    
    embeds.forEach(embed => {
      const url = embed.getAttribute('data-url');
      const theme = embed.getAttribute('data-theme') || defaultTheme;
      const lines = embed.getAttribute('data-lines') || '';
      const loadingText = embed.getAttribute('data-loading-text') || 'Loading code from GitHub...';
      
      // Set loading state
      embed.innerHTML = '<p>' + loadingText + '</p>';
      
      // Fetch and render code
      if (url) {
        fetchAndRenderCode(url, embed, theme, lines);
      } else {
        embed.innerHTML = '<p style="color: red;">Error: No GitHub URL provided</p>';
      }
    });
  }
  
  // Function to fetch and render code
  function fetchAndRenderCode(url, element, theme, lines) {
    fetch(\`\${apiBaseUrl}/html?url=\${encodeURIComponent(url)}&theme=\${theme}\${lines ? '&lines=' + lines : ''}\`)
      .then(response => {
        if (!response.ok) {
          throw new Error(\`Error fetching code: \${response.status}\`);
        }
        return response.text();
      })
      .then(html => {
        element.innerHTML = html;
      })
      .catch(error => {
        element.innerHTML = \`
          <div style="color: red; padding: 10px; border: 1px solid #ffcccc; background-color: #ffeeee;">
            <strong>Error loading GitHub code:</strong> \${error.message}<br>
            URL: \${url}
          </div>
        \`;
      });
  }
  
  // Process markers and embeds when the DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      findAndProcessGitHubMarkers();
      processGitHubEmbeds();
    });
  } else {
    findAndProcessGitHubMarkers();
    processGitHubEmbeds();
  }
})();
  `;
  
  res.send(script);
});

// Serve the Scroll Viewport integration documentation
app.get('/scroll-viewport', (req, res) => {
  res.sendFile(path.join(__dirname, 'public/scroll-viewport.html'));
});

// Explain how to use the script with Scroll Viewport
app.get('/scroll-viewport-old', (req, res) => {
  const host = `${req.protocol}://${req.get('host')}`;
  
  res.send(`
    <h1>GitHub Code Renderer for Scrollport</h1>
    <p>Learn how to embed GitHub code in your Confluence pages that will still display correctly with Scroll Viewport.</p>
    
    <h2>Instructions</h2>
    <ol>
      <li>
        <strong>Step 1:</strong> In your Confluence page, insert an HTML Macro
        <ul>
          <li>Edit your Confluence page</li>
          <li>Click the "+" button to insert a macro</li>
          <li>Search for and select "HTML"</li>
        </ul>
      </li>
      <li>
        <strong>Step 2:</strong> Add this script tag to the HTML macro
        <pre style="background:#f5f5f5; padding:10px; border-radius:5px; overflow:auto;">
&lt;script src="${host}/scroll-viewport-script?url=YOUR_GITHUB_URL"&gt;&lt;/script&gt;
        </pre>
        <p>Replace YOUR_GITHUB_URL with your GitHub file URL, for example:</p>
        <pre style="background:#f5f5f5; padding:10px; border-radius:5px; overflow:auto;">
&lt;script src="${host}/scroll-viewport-script?url=https://github.com/itext/itext-publications-examples-java/blob/develop/src/main/java/com/itextpdf/samples/htmlsamples/chapter01/C01E02_HelloWorld.java"&gt;&lt;/script&gt;
        </pre>
      </li>
      <li>
        <strong>Step 3:</strong> Optional parameters
        <ul>
          <li><code>theme</code>: Specify a syntax highlighting theme (github, github-dark, monokai, atom-one-dark, vs2015, xcode, dracula)</li>
          <li><code>lines</code>: Specify line range to display (e.g., 10-20)</li>
        </ul>
        <p>Example with all parameters:</p>
        <pre style="background:#f5f5f5; padding:10px; border-radius:5px; overflow:auto;">
&lt;script src="${host}/scroll-viewport-script?url=https://github.com/itext/itext-publications-examples-java/blob/develop/src/main/java/com/itextpdf/samples/htmlsamples/chapter01/C01E02_HelloWorld.java&theme=github-dark&lines=10-30"&gt;&lt;/script&gt;
        </pre>
      </li>
    </ol>
    
    <h2>How it Works</h2>
    <p>This approach uses a JavaScript-only solution that is compatible with Scroll Viewport's content filtering:</p>
    <ul>
      <li>The script dynamically fetches and injects the code into your page</li>
      <li>No iframe is used, avoiding Scroll Viewport's iframe filtering</li>
      <li>Styles are applied inline to ensure compatibility</li>
      <li>The actual code is loaded at runtime after the page has loaded</li>
    </ul>
    
    <h2>Example</h2>
    <p>Here's a live example of the script in action:</p>
    <script src="${host}/scroll-viewport-script?url=https://github.com/itext/itext-publications-examples-java/blob/develop/src/main/java/com/itextpdf/samples/htmlsamples/chapter01/C01E02_HelloWorld.java&theme=github"></script>
  `);
});

// Add ngrok setup guide route
app.get('/ngrok-setup', (req, res) => {
  res.sendFile(path.join(__dirname, 'public/ngrok-setup.html'));
});

// Direct bypass for Atlassian Connect descriptor
app.get('/atlassian-connect-bypass.json', (req, res) => {
  fs.readFile(path.join(__dirname, 'atlassian-connect/atlassian-connect.json'), 'utf8', (err, data) => {
    if (err) {
      console.error('Error reading Atlassian Connect descriptor:', err);
      return res.status(500).send('Error reading Atlassian Connect descriptor');
    }
    
    // Set all possible bypass headers
    res.set('Content-Type', 'application/json');
    res.set('ngrok-skip-browser-warning', 'true');
    res.set('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36');
    res.set('X-Requested-With', 'XMLHttpRequest');
    res.set('X-Forwarded-For', '127.0.0.1');
    
    // Send the raw JSON data
    res.send(data);
  });
});

// Redirect any direct requests to atlassian-connect.json to the bypass version
app.get('/atlassian-connect.json', (req, res) => {
  // Set bypass headers on the redirect
  res.set('ngrok-skip-browser-warning', 'true');
  res.set('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36');
  res.set('X-Requested-With', 'XMLHttpRequest');
  
  // Using HTML/JavaScript redirect instead of standard redirect to keep headers
  res.send(`
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <title>Redirecting...</title>
      <script>
        // Bypass script content here
        // Break out of iframe
        if (window !== window.top) {
          try { window.top.location.href = window.location.href; } catch(e) {}
        }
        
        // Fetch with custom headers
        fetch('/atlassian-connect-bypass.json', {
          headers: {
            'ngrok-skip-browser-warning': 'true',
            'User-Agent': 'Mozilla/5.0',
            'X-Requested-With': 'XMLHttpRequest'
          }
        })
        .then(response => response.json())
        .then(data => {
          document.open();
          document.write(JSON.stringify(data));
          document.close();
        })
        .catch(error => {
          console.error('Error:', error);
          window.location.href = '/atlassian-connect-bypass.json';
        });
      </script>
    </head>
    <body>
      <p>Redirecting to Atlassian Connect descriptor...</p>
    </body>
    </html>
  `);
});

// Start the server
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});

// Add endpoint for Scroll Viewport theme file
app.get('/scroll-viewport-theme.js', (req, res) => {
  try {
    // Get ngrok URL directly from environment or use the current host
    let baseUrl = process.env.NGROK_URL || `${req.protocol}://${req.get('host')}`;
    
    // Make 100% sure the URL is HTTPS
    if (baseUrl.startsWith('http://')) {
      baseUrl = baseUrl.replace('http://', 'https://');
    }
    console.log('Generating theme.js with base URL:', baseUrl);
    
    // Set proper content type and headers
    res.set({
      'Content-Type': 'application/javascript; charset=utf-8',
      'X-Content-Type-Options': 'nosniff',
      'Cache-Control': 'no-cache',
      'ngrok-skip-browser-warning': 'true'
    });
    
    // Generate a completely browser-safe script with no require() calls
    const script = `
/**
 * GitHub Code Renderer for Scroll Viewport Themes
 * Pure browser JavaScript with NO dependencies
 */
(function() {
  // Set base URL for API requests - ALWAYS uses HTTPS
  var apiBaseUrl = "${baseUrl}";
  if (apiBaseUrl.startsWith("http://")) {
    apiBaseUrl = apiBaseUrl.replace("http://", "https://");
  }
  console.log("GitHub Code Renderer initialized with API URL:", apiBaseUrl);
  
  // Process GitHub code markers when DOM is ready
  function init() {
    console.log("GitHub Code Renderer processing page...");
    findAndProcessMarkers();
  }
  
  // Find and process all GitHub markers in the page
  function findAndProcessMarkers() {
    try {
      // Find all text nodes
      var textNodes = [];
      var walker = document.createTreeWalker(
        document.body, 
        NodeFilter.SHOW_TEXT,
        null,
        false
      );
      
      var node;
      while (node = walker.nextNode()) {
        if (node.nodeValue && node.nodeValue.includes("##GITHUB:")) {
          textNodes.push(node);
        }
      }
      
      console.log("Found " + textNodes.length + " text nodes with GitHub markers");
      
      // Process all found nodes
      for (var i = 0; i < textNodes.length; i++) {
        processTextNode(textNodes[i]);
      }
    } catch (error) {
      console.error("Error finding GitHub markers:", error);
    }
  }
  
  // Process a single text node
  function processTextNode(textNode) {
    try {
      var text = textNode.nodeValue;
      
      // Create regex pattern as a string first to avoid unterminated group errors
      // This pattern will match the full GitHub URL including the domain and path
      var regexPattern = "##GITHUB:(https?:\\\\/\\\\/(?:github\\\\.com|raw\\\\.githubusercontent\\\\.com)[^#]+)(?::([^:]+))?(?::([^#]+))?##";
      var regex = new RegExp(regexPattern, "g");
      
      var matches = [];
      var match;
      
      // Find all markers in this text
      while ((match = regex.exec(text)) !== null) {
        var url = match[1];
        console.log("Found GitHub URL:", url);
        
        matches.push({
          fullMatch: match[0],
          url: url,
          lines: match[2] || "",
          theme: match[3] || "github"
        });
      }
      
      // Skip if no matches
      if (matches.length === 0) return;
      
      // Split text and replace with code blocks
      // Use string-based regex to avoid errors with forward slashes
      var splitRegexPattern = "##GITHUB:https?:\\\\/\\\\/(?:github\\\\.com|raw\\\\.githubusercontent\\\\.com)[^#]+(?::(?:[^:]+))?(?::(?:[^#]+))?##";
      var splitRegex = new RegExp(splitRegexPattern, "g");
      var parts = text.split(splitRegex);
      var parent = textNode.parentNode;
      
      // Remove original text node
      parent.removeChild(textNode);
      
      // Build replacement content
      for (var i = 0; i < parts.length; i++) {
        // Add text part
        if (parts[i]) {
          parent.appendChild(document.createTextNode(parts[i]));
        }
        
        // Add code block if there's a match
        if (i < matches.length) {
          insertGithubCode(parent, matches[i]);
        }
      }
    } catch (error) {
      console.error("Error processing text node:", error);
    }
  }
  
  // Insert a GitHub code block
  function insertGithubCode(parent, codeData) {
    try {
      // Validate URL before proceeding
      if (!codeData.url || 
          (!codeData.url.includes("github.com") && 
           !codeData.url.includes("raw.githubusercontent.com"))) {
        console.error("Invalid GitHub URL:", codeData.url);
        var errorDiv = document.createElement("div");
        errorDiv.className = "github-code-error";
        errorDiv.innerHTML = 
          '<div style="padding: 10px; background:#ffeeee; border:1px solid #ffcccc; color:#cc0000; border-radius:4px;">' +
          'Error: Invalid GitHub URL format. URL must contain github.com or raw.githubusercontent.com' + '</div>';
        parent.appendChild(errorDiv);
        return;
      }

      // Create placeholder
      var placeholder = document.createElement("div");
      placeholder.className = "github-code-loading";
      placeholder.textContent = "Loading GitHub code...";
      parent.appendChild(placeholder);
      
      // Create fully qualified URL - ALWAYS HTTPS
      var fetchUrl = apiBaseUrl + "/html" +
                "?url=" + encodeURIComponent(codeData.url) + 
                "&theme=" + encodeURIComponent(codeData.theme) +
                (codeData.lines ? "&lines=" + encodeURIComponent(codeData.lines) : "");
      
      console.log("Fetching code from:", fetchUrl, "GitHub URL:", codeData.url);
      
      // Fetch the code
      fetch(fetchUrl)
        .then(function(response) {
          if (!response.ok) {
            throw new Error("HTTP error " + response.status);
          }
          return response.text();
        })
        .then(function(html) {
          // Insert the HTML
          var div = document.createElement("div");
          div.innerHTML = html;
          
          if (div.firstChild) {
            placeholder.parentNode.replaceChild(div.firstChild, placeholder);
          } else {
            placeholder.innerHTML = html;
          }
        })
        .catch(function(error) {
          console.error("Error fetching code:", error);
          placeholder.innerHTML = 
            '<div style="padding: 10px; background:#ffeeee; border:1px solid #ffcccc; color:#cc0000; border-radius:4px;">' +
            'Error loading GitHub code: ' + error.message + '</div>';
        });
    } catch (error) {
      console.error("Error inserting GitHub code:", error);
    }
  }
  
  // Run when the DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init);
  } else {
    // DOM already loaded, run immediately
    init();
  }
})();`;
    
    // Send the script
    res.send(script);
  } catch (error) {
    console.error('Global error in theme.js endpoint:', error);
    res.status(500).send(`console.error("Server error generating theme script: ${error.message}");`);
  }
});